module 'sets' ['add_element'/2,'del_element'/2,'filter'/2,'fold'/3,'from_list'/1,'intersection'/1,'intersection'/2,'is_disjoint'/2,'is_element'/2,'is_empty'/1,'is_set'/1,'is_subset'/2,'module_info'/0,'module_info'/1,'new'/0,'size'/1,'subtract'/2,'to_list'/1,'union'/1,'union'/2] attributes [ 'file' = [{[115|[114|[99|[47|[115|[101|[116|[115|[46|[101|[114|[108]]]]]]]]]]]],1}]
, 'export_type' = [{'set',0}|[{'set',1}]]
, 'type' = [{'seg',{'type',59,'tuple','any'},[]}]
, 'type' = [{'segs',{'type',60,'tuple','any'},[{'var',60,'_Element'}]}]
, 'record' = [{'set',[{'typed_record_field',{'record_field',64,{'atom',64,'size'},{'integer',64,0}},{'type',64,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',65,{'atom',65,'n'},{'integer',65,16}},{'type',65,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',66,{'atom',66,'maxn'},{'integer',66,16}},{'type',66,'pos_integer',[]}}|[{'typed_record_field',{'record_field',67,{'atom',67,'bso'},{'op',67,'div',{'integer',67,16},{'integer',67,2}}},{'type',67,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',68,{'atom',68,'exp_size'},{'op',68,'*',{'integer',68,16},{'integer',68,5}}},{'type',68,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',69,{'atom',69,'con_size'},{'op',69,'*',{'integer',69,16},{'integer',69,3}}},{'type',69,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',70,{'atom',70,'empty'}},{'user_type',70,'seg',[]}}|[{'typed_record_field',{'record_field',71,{'atom',71,'segs'}},{'user_type',71,'segs',[{'var',71,'_'}]}}]]]]]]]]}]
, 'type' = [{'set',{'user_type',74,'set',[{'var',74,'_'}]},[]}]
, 'opaque' = [{'set',{'type',76,'record',[{'atom',76,'set'}|[{'type',76,'field_type',[{'atom',76,'segs'}|[{'user_type',76,'segs',[{'var',76,'Element'}]}]]}]]},[{'var',76,'Element'}]}]
, 'spec' = [{{'new',0},[{'type',81,'fun',[{'type',81,'product',[]}|[{'user_type',81,'set',[]}]]}]}]
, 'spec' = [{{'is_set',1},[{'type',88,'bounded_fun',[{'type',88,'fun',[{'type',88,'product',[{'var',88,'Set'}]}|[{'type',88,'boolean',[]}]]}|[[{'type',89,'constraint',[{'atom',89,'is_subtype'}|[[{'var',89,'Set'}|[{'type',89,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'size',1},[{'type',95,'bounded_fun',[{'type',95,'fun',[{'type',95,'product',[{'var',95,'Set'}]}|[{'type',95,'non_neg_integer',[]}]]}|[[{'type',96,'constraint',[{'atom',96,'is_subtype'}|[[{'var',96,'Set'}|[{'user_type',96,'set',[]}]]]]}]]]}]}]
, 'spec' = [{{'is_empty',1},[{'type',101,'bounded_fun',[{'type',101,'fun',[{'type',101,'product',[{'var',101,'Set'}]}|[{'type',101,'boolean',[]}]]}|[[{'type',102,'constraint',[{'atom',102,'is_subtype'}|[[{'var',102,'Set'}|[{'user_type',102,'set',[]}]]]]}]]]}]}]
, 'spec' = [{{'to_list',1},[{'type',107,'bounded_fun',[{'type',107,'fun',[{'type',107,'product',[{'var',107,'Set'}]}|[{'var',107,'List'}]]}|[[{'type',108,'constraint',[{'atom',108,'is_subtype'}|[[{'var',108,'Set'}|[{'user_type',108,'set',[{'var',108,'Element'}]}]]]]}|[{'type',109,'constraint',[{'atom',109,'is_subtype'}|[[{'var',109,'List'}|[{'type',109,'list',[{'var',109,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'from_list',1},[{'type',115,'bounded_fun',[{'type',115,'fun',[{'type',115,'product',[{'var',115,'List'}]}|[{'var',115,'Set'}]]}|[[{'type',116,'constraint',[{'atom',116,'is_subtype'}|[[{'var',116,'List'}|[{'type',116,'list',[{'var',116,'Element'}]}]]]]}|[{'type',117,'constraint',[{'atom',117,'is_subtype'}|[[{'var',117,'Set'}|[{'user_type',117,'set',[{'var',117,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'is_element',2},[{'type',123,'bounded_fun',[{'type',123,'fun',[{'type',123,'product',[{'var',123,'Element'}|[{'var',123,'Set'}]]}|[{'type',123,'boolean',[]}]]}|[[{'type',124,'constraint',[{'atom',124,'is_subtype'}|[[{'var',124,'Set'}|[{'user_type',124,'set',[{'var',124,'Element'}]}]]]]}]]]}]}]
, 'spec' = [{{'add_element',2},[{'type',132,'bounded_fun',[{'type',132,'fun',[{'type',132,'product',[{'var',132,'Element'}|[{'var',132,'Set1'}]]}|[{'var',132,'Set2'}]]}|[[{'type',133,'constraint',[{'atom',133,'is_subtype'}|[[{'var',133,'Set1'}|[{'user_type',133,'set',[{'var',133,'Element'}]}]]]]}|[{'type',134,'constraint',[{'atom',134,'is_subtype'}|[[{'var',134,'Set2'}|[{'user_type',134,'set',[{'var',134,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'del_element',2},[{'type',148,'bounded_fun',[{'type',148,'fun',[{'type',148,'product',[{'var',148,'Element'}|[{'var',148,'Set1'}]]}|[{'var',148,'Set2'}]]}|[[{'type',149,'constraint',[{'atom',149,'is_subtype'}|[[{'var',149,'Set1'}|[{'user_type',149,'set',[{'var',149,'Element'}]}]]]]}|[{'type',150,'constraint',[{'atom',150,'is_subtype'}|[[{'var',150,'Set2'}|[{'user_type',150,'set',[{'var',150,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'update_bucket',3},[{'type',164,'bounded_fun',[{'type',164,'fun',[{'type',164,'product',[{'var',164,'Set1'}|[{'var',164,'Slot'}|[{'var',164,'Bkt'}]]]}|[{'var',164,'Set2'}]]}|[[{'type',165,'constraint',[{'atom',165,'is_subtype'}|[[{'var',165,'Set1'}|[{'user_type',165,'set',[{'var',165,'Element'}]}]]]]}|[{'type',166,'constraint',[{'atom',166,'is_subtype'}|[[{'var',166,'Set2'}|[{'user_type',166,'set',[{'var',166,'Element'}]}]]]]}|[{'type',167,'constraint',[{'atom',167,'is_subtype'}|[[{'var',167,'Slot'}|[{'type',167,'non_neg_integer',[]}]]]]}|[{'type',168,'constraint',[{'atom',168,'is_subtype'}|[[{'var',168,'Bkt'}|[{'type',168,'list',[{'var',168,'Element'}]}]]]]}]]]]]]}]}]
, 'spec' = [{{'union',2},[{'type',178,'bounded_fun',[{'type',178,'fun',[{'type',178,'product',[{'var',178,'Set1'}|[{'var',178,'Set2'}]]}|[{'var',178,'Set3'}]]}|[[{'type',179,'constraint',[{'atom',179,'is_subtype'}|[[{'var',179,'Set1'}|[{'user_type',179,'set',[{'var',179,'Element'}]}]]]]}|[{'type',180,'constraint',[{'atom',180,'is_subtype'}|[[{'var',180,'Set2'}|[{'user_type',180,'set',[{'var',180,'Element'}]}]]]]}|[{'type',181,'constraint',[{'atom',181,'is_subtype'}|[[{'var',181,'Set3'}|[{'user_type',181,'set',[{'var',181,'Element'}]}]]]]}]]]]]}]}]
, 'spec' = [{{'union',1},[{'type',189,'bounded_fun',[{'type',189,'fun',[{'type',189,'product',[{'var',189,'SetList'}]}|[{'var',189,'Set'}]]}|[[{'type',190,'constraint',[{'atom',190,'is_subtype'}|[[{'var',190,'SetList'}|[{'type',190,'list',[{'user_type',190,'set',[{'var',190,'Element'}]}]}]]]]}|[{'type',191,'constraint',[{'atom',191,'is_subtype'}|[[{'var',191,'Set'}|[{'user_type',191,'set',[{'var',191,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'union1',2},[{'type',197,'fun',[{'type',197,'product',[{'user_type',197,'set',[{'var',197,'E'}]}|[{'type',197,'list',[{'user_type',197,'set',[{'var',197,'E'}]}]}]]}|[{'user_type',197,'set',[{'var',197,'E'}]}]]}]}]
, 'spec' = [{{'intersection',2},[{'type',204,'bounded_fun',[{'type',204,'fun',[{'type',204,'product',[{'var',204,'Set1'}|[{'var',204,'Set2'}]]}|[{'var',204,'Set3'}]]}|[[{'type',205,'constraint',[{'atom',205,'is_subtype'}|[[{'var',205,'Set1'}|[{'user_type',205,'set',[{'var',205,'Element'}]}]]]]}|[{'type',206,'constraint',[{'atom',206,'is_subtype'}|[[{'var',206,'Set2'}|[{'user_type',206,'set',[{'var',206,'Element'}]}]]]]}|[{'type',207,'constraint',[{'atom',207,'is_subtype'}|[[{'var',207,'Set3'}|[{'user_type',207,'set',[{'var',207,'Element'}]}]]]]}]]]]]}]}]
, 'spec' = [{{'intersection',1},[{'type',215,'bounded_fun',[{'type',215,'fun',[{'type',215,'product',[{'var',215,'SetList'}]}|[{'var',215,'Set'}]]}|[[{'type',216,'constraint',[{'atom',216,'is_subtype'}|[[{'var',216,'SetList'}|[{'type',216,'nonempty_list',[{'user_type',216,'set',[{'var',216,'Element'}]}]}]]]]}|[{'type',217,'constraint',[{'atom',217,'is_subtype'}|[[{'var',217,'Set'}|[{'user_type',217,'set',[{'var',217,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'intersection1',2},[{'type',222,'fun',[{'type',222,'product',[{'user_type',222,'set',[{'var',222,'E'}]}|[{'type',222,'list',[{'user_type',222,'set',[{'var',222,'E'}]}]}]]}|[{'user_type',222,'set',[{'var',222,'E'}]}]]}]}]
, 'spec' = [{{'is_disjoint',2},[{'type',229,'bounded_fun',[{'type',229,'fun',[{'type',229,'product',[{'var',229,'Set1'}|[{'var',229,'Set2'}]]}|[{'type',229,'boolean',[]}]]}|[[{'type',230,'constraint',[{'atom',230,'is_subtype'}|[[{'var',230,'Set1'}|[{'user_type',230,'set',[{'var',230,'Element'}]}]]]]}|[{'type',231,'constraint',[{'atom',231,'is_subtype'}|[[{'var',231,'Set2'}|[{'user_type',231,'set',[{'var',231,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'subtract',2},[{'type',244,'bounded_fun',[{'type',244,'fun',[{'type',244,'product',[{'var',244,'Set1'}|[{'var',244,'Set2'}]]}|[{'var',244,'Set3'}]]}|[[{'type',245,'constraint',[{'atom',245,'is_subtype'}|[[{'var',245,'Set1'}|[{'user_type',245,'set',[{'var',245,'Element'}]}]]]]}|[{'type',246,'constraint',[{'atom',246,'is_subtype'}|[[{'var',246,'Set2'}|[{'user_type',246,'set',[{'var',246,'Element'}]}]]]]}|[{'type',247,'constraint',[{'atom',247,'is_subtype'}|[[{'var',247,'Set3'}|[{'user_type',247,'set',[{'var',247,'Element'}]}]]]]}]]]]]}]}]
, 'spec' = [{{'is_subset',2},[{'type',254,'bounded_fun',[{'type',254,'fun',[{'type',254,'product',[{'var',254,'Set1'}|[{'var',254,'Set2'}]]}|[{'type',254,'boolean',[]}]]}|[[{'type',255,'constraint',[{'atom',255,'is_subtype'}|[[{'var',255,'Set1'}|[{'user_type',255,'set',[{'var',255,'Element'}]}]]]]}|[{'type',256,'constraint',[{'atom',256,'is_subtype'}|[[{'var',256,'Set2'}|[{'user_type',256,'set',[{'var',256,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'fold',3},[{'type',262,'bounded_fun',[{'type',262,'fun',[{'type',262,'product',[{'var',262,'Function'}|[{'var',262,'Acc0'}|[{'var',262,'Set'}]]]}|[{'var',262,'Acc1'}]]}|[[{'type',263,'constraint',[{'atom',263,'is_subtype'}|[[{'var',263,'Function'}|[{'type',263,'fun',[{'type',263,'product',[{'var',263,'Element'}|[{'var',263,'AccIn'}]]}|[{'var',263,'AccOut'}]]}]]]]}|[{'type',264,'constraint',[{'atom',264,'is_subtype'}|[[{'var',264,'Set'}|[{'user_type',264,'set',[{'var',264,'Element'}]}]]]]}|[{'type',265,'constraint',[{'atom',265,'is_subtype'}|[[{'var',265,'Acc0'}|[{'var',265,'Acc'}]]]]}|[{'type',266,'constraint',[{'atom',266,'is_subtype'}|[[{'var',266,'Acc1'}|[{'var',266,'Acc'}]]]]}|[{'type',267,'constraint',[{'atom',267,'is_subtype'}|[[{'var',267,'AccIn'}|[{'var',267,'Acc'}]]]]}|[{'type',268,'constraint',[{'atom',268,'is_subtype'}|[[{'var',268,'AccOut'}|[{'var',268,'Acc'}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'filter',2},[{'type',273,'bounded_fun',[{'type',273,'fun',[{'type',273,'product',[{'var',273,'Pred'}|[{'var',273,'Set1'}]]}|[{'var',273,'Set2'}]]}|[[{'type',274,'constraint',[{'atom',274,'is_subtype'}|[[{'var',274,'Pred'}|[{'type',274,'fun',[{'type',274,'product',[{'var',274,'Element'}]}|[{'type',274,'boolean',[]}]]}]]]]}|[{'type',275,'constraint',[{'atom',275,'is_subtype'}|[[{'var',275,'Set1'}|[{'user_type',275,'set',[{'var',275,'Element'}]}]]]]}|[{'type',276,'constraint',[{'atom',276,'is_subtype'}|[[{'var',276,'Set2'}|[{'user_type',276,'set',[{'var',276,'Element'}]}]]]]}]]]]]}]}]
, 'spec' = [{{'get_slot',2},[{'type',282,'fun',[{'type',282,'product',[{'user_type',282,'set',[{'var',282,'E'}]}|[{'var',282,'E'}]]}|[{'type',282,'non_neg_integer',[]}]]}]}]
, 'spec' = [{{'get_bucket',2},[{'type',291,'fun',[{'type',291,'product',[{'user_type',291,'set',[]}|[{'type',291,'non_neg_integer',[]}]]}|[{'type',291,'term',[]}]]}]}]
, 'spec' = [{{'maybe_expand',1},[{'type',358,'fun',[{'type',358,'product',[{'user_type',358,'set',[{'var',358,'E'}]}]}|[{'user_type',358,'set',[{'var',358,'E'}]}]]}]}]
, 'spec' = [{{'maybe_expand_segs',1},[{'type',376,'fun',[{'type',376,'product',[{'user_type',376,'set',[{'var',376,'E'}]}]}|[{'user_type',376,'set',[{'var',376,'E'}]}]]}]}]
, 'spec' = [{{'maybe_contract',2},[{'type',383,'fun',[{'type',383,'product',[{'user_type',383,'set',[{'var',383,'E'}]}|[{'type',383,'non_neg_integer',[]}]]}|[{'user_type',383,'set',[{'var',383,'E'}]}]]}]}]
, 'spec' = [{{'maybe_contract_segs',1},[{'type',402,'fun',[{'type',402,'product',[{'user_type',402,'set',[{'var',402,'E'}]}]}|[{'user_type',402,'set',[{'var',402,'E'}]}]]}]}]
, 'spec' = [{{'rehash',4},[{'type',410,'fun',[{'type',410,'product',[{'type',410,'list',[{'var',410,'T'}]}|[{'type',410,'integer',[]}|[{'type',410,'pos_integer',[]}|[{'type',410,'pos_integer',[]}]]]]}|[{'type',410,'tuple',[{'type',410,'list',[{'var',410,'T'}]}|[{'type',410,'list',[{'var',410,'T'}]}]]}]]}]}]
, 'spec' = [{{'mk_seg',1},[{'type',420,'fun',[{'type',420,'product',[{'integer',420,16}]}|[{'user_type',420,'seg',[]}]]}]}]
, 'spec' = [{{'expand_segs',2},[{'type',429,'fun',[{'type',429,'product',[{'user_type',429,'segs',[{'var',429,'E'}]}|[{'user_type',429,'seg',[]}]]}|[{'user_type',429,'segs',[{'var',429,'E'}]}]]}]}]
, 'spec' = [{{'contract_segs',1},[{'type',447,'fun',[{'type',447,'product',[{'user_type',447,'segs',[{'var',447,'E'}]}]}|[{'user_type',447,'segs',[{'var',447,'E'}]}]]}]}] ] 'new'/0 = fun () -> let <Empty> = apply 'mk_seg'/1 (16) in {'set',0,16,16,8,80,48,Empty,{Empty}}
'is_set'/1 = fun (_0) -> case _0 of <{'set',_2,_3,_4,_5,_6,_7,_8,_9}> when 'true' -> 'true'
<_10> when 'true' -> 'false' end
'size'/1 = fun (_0) -> (case _0 of (<({'set',_rec0,_3,_4,_5,_6,_7,_8,_9}-|['compiler_generated'] )> when 'true' -> _rec0-|['compiler_generated'] )
(<_10> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'is_empty'/1 = fun (_0) -> (case _0 of (<({'set',_rec1,_4,_5,_6,_7,_8,_9,_10}-|['compiler_generated'] )> when 'true' -> call 'erlang':'=:=' (_rec1,0)-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'to_list'/1 = fun (_0) -> let <_5> = fun (_2,_1) -> [_2|_1] in apply 'fold'/3 (_5,[],_0)
'from_list'/1 = fun (_0) -> let <_6> = fun (_3,_2) -> apply 'add_element'/2 (_3,_2) in let <_1> = apply 'new'/0 () in call 'lists':'foldl' (_6,_1,_0)
'is_element'/2 = fun (_0,_1) -> let <Slot> = apply 'get_slot'/2 (_1,_0) in let <Bkt> = apply 'get_bucket'/2 (_1,Slot) in call 'lists':'member' (_0,Bkt)
'add_element'/2 = fun (_0,_1) -> let <Slot> = apply 'get_slot'/2 (_1,_0) in let <Bkt> = apply 'get_bucket'/2 (_1,Slot) in case call 'lists':'member' (_0,Bkt) of <'true'> when 'true' -> _1
<'false'> when 'true' -> let <S1> = apply 'update_bucket'/3 (_1,Slot,[_0|Bkt]) in apply 'maybe_expand'/1 (S1)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'del_element'/2 = fun (_0,_1) -> let <Slot> = apply 'get_slot'/2 (_1,_0) in let <Bkt> = apply 'get_bucket'/2 (_1,Slot) in case call 'lists':'member' (_0,Bkt) of <'false'> when 'true' -> _1
<'true'> when 'true' -> let <_4> = call 'lists':'delete' (_0,Bkt) in let <S1> = apply 'update_bucket'/3 (_1,Slot,_4) in apply 'maybe_contract'/2 (S1,1)
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
'update_bucket'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'-' (_1,1) in let <_4> = call 'erlang':'div' (_3,16) in let <SegI> = call 'erlang':'+' (_4,1) in let <_6> = call 'erlang':'-' (_1,1) in let <_7> = call 'erlang':'rem' (_6,16) in let <BktI> = call 'erlang':'+' (_7,1) in (case _0 of (<({'set',_20,_21,_22,_23,_24,_25,_26,_rec2}-|['compiler_generated'] )> when 'true' -> let <Seg> = call 'erlang':'element' (SegI,_rec2) in let <_13> = call 'erlang':'setelement' (BktI,Seg,_2) in let <_rec3> = call 'erlang':'setelement' (SegI,_rec2,_13) in case _0 of <{'set',_28,_29,_30,_31,_32,_33,_34,_35}> when 'true' -> call 'erlang':'setelement' (9,_0,_rec3)
(<_36> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_27> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'union'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'set',_27,_28,_29,_30,_31,_32,_33,_34},S2 = {'set',_35,_36,_37,_38,_39,_40,_41,_42}> when (try let <_13> = call 'erlang':'element' (2,S1) in let <_12> = call 'erlang':'element' (2,S2) in call 'erlang':'<' (_13,_12) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> let <_19> = fun (_16,_15) -> apply 'add_element'/2 (_16,_15) in apply 'fold'/3 (_19,S2,S1)
<S1,S2> when 'true' -> let <_24> = fun (_21,_20) -> apply 'add_element'/2 (_21,_20) in apply 'fold'/3 (_24,S1,S2) end
'union'/1 = fun (_0) -> case _0 of <[S1|[S2|Ss]]> when 'true' -> let <_1> = apply 'union'/2 (S1,S2) in apply 'union1'/2 (_1,Ss)
<[S|[]]> when 'true' -> S
<[]> when 'true' -> apply 'new'/0 ()
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'union',1}}] )-|['compiler_generated'] ) end
'union1'/2 = fun (_0,_1) -> case <_0,_1> of <S1,[S2|Ss]> when 'true' -> let <_2> = apply 'union'/2 (S1,S2) in apply 'union1'/2 (_2,Ss)
<S1,[]> when 'true' -> S1
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'union1',2}}] )-|['compiler_generated'] ) end
'intersection'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'set',_23,_24,_25,_26,_27,_28,_29,_30},S2 = {'set',_31,_32,_33,_34,_35,_36,_37,_38}> when (try let <_13> = call 'erlang':'element' (2,S1) in let <_12> = call 'erlang':'element' (2,S2) in call 'erlang':'<' (_13,_12) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> let <_17> = fun (_15) -> apply 'is_element'/2 (_15,S2) in apply 'filter'/2 (_17,S1)
<S1,S2> when 'true' -> let <_20> = fun (_18) -> apply 'is_element'/2 (_18,S1) in apply 'filter'/2 (_20,S2) end
'intersection'/1 = fun (_0) -> case _0 of <[S1|[S2|Ss]]> when 'true' -> let <_1> = apply 'intersection'/2 (S1,S2) in apply 'intersection1'/2 (_1,Ss)
<[S|[]]> when 'true' -> S
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'intersection',1}}] )-|['compiler_generated'] ) end
'intersection1'/2 = fun (_0,_1) -> case <_0,_1> of <S1,[S2|Ss]> when 'true' -> let <_2> = apply 'intersection'/2 (S1,S2) in apply 'intersection1'/2 (_2,Ss)
<S1,[]> when 'true' -> S1
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'intersection1',2}}] )-|['compiler_generated'] ) end
'is_disjoint'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'set',_29,_30,_31,_32,_33,_34,_35,_36},S2 = {'set',_37,_38,_39,_40,_41,_42,_43,_44}> when (try let <_13> = call 'erlang':'element' (2,S1) in let <_12> = call 'erlang':'element' (2,S2) in call 'erlang':'<' (_13,_12) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> let <_20> = fun (_17,_16) -> case <_17,_16> of <_45,'false'> when 'true' -> 'false'
<E,'true'> when 'true' -> let <_15> = apply 'is_element'/2 (E,S2) in call 'erlang':'not' (_15)
(<_19,_18> when 'true' -> (primop 'match_fail' ({'function_clause',_19,_18})-|[{'function_name',{'-is_disjoint/2-fun-0-',2}}] )-|['compiler_generated'] ) end in apply 'fold'/3 (_20,'true',S1)
<S1,S2> when 'true' -> let <_26> = fun (_23,_22) -> case <_23,_22> of <_46,'false'> when 'true' -> 'false'
<E,'true'> when 'true' -> let <_21> = apply 'is_element'/2 (E,S1) in call 'erlang':'not' (_21)
(<_25,_24> when 'true' -> (primop 'match_fail' ({'function_clause',_25,_24})-|[{'function_name',{'-is_disjoint/2-fun-1-',2}}] )-|['compiler_generated'] ) end in apply 'fold'/3 (_26,'true',S2) end
'subtract'/2 = fun (_0,_1) -> let <_5> = fun (_3) -> let <_2> = apply 'is_element'/2 (_3,_1) in call 'erlang':'not' (_2) in apply 'filter'/2 (_5,_0)
'is_subset'/2 = fun (_0,_1) -> let <_8> = fun (_5,_4) -> (case _4 of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'is_element'/2 (_5,_1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_2> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_2}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) in apply 'fold'/3 (_8,'true',_0)
'fold'/3 = fun (_0,_1,_2) -> apply 'fold_set'/3 (_0,_1,_2)
'filter'/2 = fun (_0,_1) -> apply 'filter_set'/2 (_0,_1)
'get_slot'/2 = fun (_0,_1) -> (case _0 of (<({'set',_15,_16,_rec5,_17,_18,_19,_20,_21}-|['compiler_generated'] )> when 'true' -> let <H> = call 'erlang':'phash' (_1,_rec5) in case <> of <> when (try (let <_7> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (_0,('set'-|['compiler_generated'] ),(9-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_5-|['compiler_generated'] )> when 'true' -> (_5-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_8> = call 'erlang':'=:=' ((_7-|['compiler_generated'] ),'true') in let <_9> = call 'erlang':'element' (3,_0) in let <_10> = call 'erlang':'>' (H,_9) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_8,_10)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case _0 of (<({'set',_23,_24,_25,_rec6,_26,_27,_28,_29}-|['compiler_generated'] )> when 'true' -> call 'erlang':'-' (H,_rec6)-|['compiler_generated'] )
(<_30> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<> when 'true' -> H end-|['compiler_generated'] )
(<_22> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'get_bucket'/2 = fun (_0,_1) -> (case _0 of (<({'set',_6,_7,_8,_9,_10,_11,_12,_rec7}-|['compiler_generated'] )> when 'true' -> apply 'get_bucket_s'/2 (_rec7,_1)-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'fold_set'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <F,Acc,D> when call 'erlang':'is_function' (F,2) -> (case D of (<({'set',_10,_11,_12,_13,_14,_15,_16,_rec8}-|['compiler_generated'] )> when 'true' -> let <_6> = call 'erlang':'tuple_size' (_rec8) in apply 'fold_segs'/4 (F,Acc,_rec8,_6)-|['compiler_generated'] )
(<_17> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7})-|[{'function_name',{'fold_set',3}}] )-|['compiler_generated'] ) end
'fold_segs'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <F,Acc,Segs,I> when call 'erlang':'>=' (I,1) -> let <Seg> = call 'erlang':'element' (I,Segs) in let <_6> = call 'erlang':'tuple_size' (Seg) in let <_7> = apply 'fold_seg'/4 (F,Acc,Seg,_6) in let <_5> = call 'erlang':'-' (I,1) in apply 'fold_segs'/4 (F,_7,Segs,_5)
<_12,Acc,_13,_14> when 'true' -> Acc end
'fold_seg'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <F,Acc,Seg,I> when call 'erlang':'>=' (I,1) -> let <_5> = call 'erlang':'element' (I,Seg) in let <_6> = apply 'fold_bucket'/3 (F,Acc,_5) in let <_4> = call 'erlang':'-' (I,1) in apply 'fold_seg'/4 (F,_6,Seg,_4)
<_11,Acc,_12,_13> when 'true' -> Acc end
'fold_bucket'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <F,Acc,[E|Bkt]> when 'true' -> let <_3> = apply F (E,Acc) in apply 'fold_bucket'/3 (F,_3,Bkt)
<_7,Acc,[]> when 'true' -> Acc
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'fold_bucket',3}}] )-|['compiler_generated'] ) end
'filter_set'/2 = fun (_0,_1) -> case <_0,_1> of <F,D> when call 'erlang':'is_function' (F,1) -> (case D of (<({'set',_12,_13,_14,_15,_16,_17,_18,_rec9}-|['compiler_generated'] )> when 'true' -> let <Segs0> = call 'erlang':'tuple_to_list' (_rec9) in case apply 'filter_seg_list'/4 (F,Segs0,[],0) of <{Segs1,Fc}> when 'true' -> let <_rec10> = call 'erlang':'list_to_tuple' (Segs1) in case D of <{'set',_20,_21,_22,_23,_24,_25,_26,_27}> when 'true' -> let <_9> = call 'erlang':'setelement' (9,D,_rec10) in apply 'maybe_contract'/2 (_9,Fc)
(<_28> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10})-|[{'function_name',{'filter_set',2}}] )-|['compiler_generated'] ) end
'filter_seg_list'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <F,[Seg|Segs],Fss,Fc0> when 'true' -> let <Bkts0> = call 'erlang':'tuple_to_list' (Seg) in case apply 'filter_bkt_list'/4 (F,Bkts0,[],Fc0) of <{Bkts1,Fc1}> when 'true' -> let <_6> = call 'erlang':'list_to_tuple' (Bkts1) in apply 'filter_seg_list'/4 (F,Segs,[_6|Fss],Fc1)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<_12,[],Fss,Fc> when 'true' -> let <_7> = call 'lists':'reverse' (Fss,[]) in {_7,Fc}
(<_11,_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8})-|[{'function_name',{'filter_seg_list',4}}] )-|['compiler_generated'] ) end
'filter_bkt_list'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <F,[Bkt0|Bkts],Fbs,Fc0> when 'true' -> case apply 'filter_bucket'/4 (F,Bkt0,[],Fc0) of <{Bkt1,Fc1}> when 'true' -> apply 'filter_bkt_list'/4 (F,Bkts,[Bkt1|Fbs],Fc1)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<_10,[],Fbs,Fc> when 'true' -> let <_5> = call 'lists':'reverse' (Fbs) in {_5,Fc}
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'filter_bkt_list',4}}] )-|['compiler_generated'] ) end
'filter_bucket'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <F,[E|Bkt],Fb,Fc> when 'true' -> case apply F (E) of <'true'> when 'true' -> apply 'filter_bucket'/4 (F,Bkt,[E|Fb],Fc)
<'false'> when 'true' -> let <_4> = call 'erlang':'+' (Fc,1) in apply 'filter_bucket'/4 (F,Bkt,Fb,_4)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<_10,[],Fb,Fc> when 'true' -> {Fb,Fc}
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'filter_bucket',4}}] )-|['compiler_generated'] ) end
'get_bucket_s'/2 = fun (_0,_1) -> let <_2> = call 'erlang':'-' (_1,1) in let <_3> = call 'erlang':'div' (_2,16) in let <SegI> = call 'erlang':'+' (_3,1) in let <_5> = call 'erlang':'-' (_1,1) in let <_6> = call 'erlang':'rem' (_5,16) in let <BktI> = call 'erlang':'+' (_6,1) in let <_8> = call 'erlang':'element' (SegI,_0) in call 'erlang':'element' (BktI,_8)
'put_bucket_s'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'-' (_1,1) in let <_4> = call 'erlang':'div' (_3,16) in let <SegI> = call 'erlang':'+' (_4,1) in let <_6> = call 'erlang':'-' (_1,1) in let <_7> = call 'erlang':'rem' (_6,16) in let <BktI> = call 'erlang':'+' (_7,1) in let <_9> = call 'erlang':'element' (SegI,_0) in let <Seg> = call 'erlang':'setelement' (BktI,_9,_2) in call 'erlang':'setelement' (SegI,_0,Seg)
'maybe_expand'/1 = fun (_0) -> case _0 of <T0 = {'set',_39,_40,_41,_42,_43,_44,_45,_46}> when (try let <_6> = call 'erlang':'element' (2,T0) in let <_7> = call 'erlang':'+' (_6,1) in let <_5> = call 'erlang':'element' (6,T0) in call 'erlang':'>' (_7,_5) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> let <T> = apply 'maybe_expand_segs'/1 (T0) in (case T of (<({'set',_47,_rec12,_48,_49,_50,_51,_52,_53}-|['compiler_generated'] )> when 'true' -> let <N> = call 'erlang':'+' (_rec12,1) in (case T of (<({'set',_55,_56,_57,_58,_59,_60,_61,_rec13}-|['compiler_generated'] )> when 'true' -> (case T of (<({'set',_63,_64,_65,_rec14,_66,_67,_68,_69}-|['compiler_generated'] )> when 'true' -> let <Slot1> = call 'erlang':'-' (N,_rec14) in let <B> = apply 'get_bucket_s'/2 (_rec13,Slot1) in (case T of (<({'set',_71,_72,_rec15,_73,_74,_75,_76,_77}-|['compiler_generated'] )> when 'true' -> case apply 'rehash'/4 (B,Slot1,N,_rec15) of <{B1,B2}> when 'true' -> let <Segs1> = apply 'put_bucket_s'/3 (_rec13,Slot1,B1) in let <Segs2> = apply 'put_bucket_s'/3 (Segs1,N,B2) in (case T of (<({'set',_rec28,_79,_80,_81,_82,_83,_84,_85}-|['compiler_generated'] )> when 'true' -> let <_rec16> = call 'erlang':'+' (_rec28,1) in let <_rec17> = call 'erlang':'*' (N,5) in let <_rec18> = call 'erlang':'*' (N,3) in case T of <{'set',_rec20,_rec21,_rec22,_rec23,_rec24,_rec25,_rec26,_rec27}> when 'true' -> {'set',_rec16,N,_rec22,_rec23,_rec17,_rec18,_rec26,Segs2}
(<_87> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_86> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_23> when 'true' -> primop 'match_fail' ({'badmatch',_23})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_78> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_70> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_62> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_54> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<T> when 'true' -> (case T of (<({'set',_rec31,_88,_89,_90,_91,_92,_93,_94}-|['compiler_generated'] )> when 'true' -> let <_rec29> = call 'erlang':'+' (_rec31,1) in case T of <{'set',_96,_97,_98,_99,_100,_101,_102,_103}> when 'true' -> call 'erlang':'setelement' (2,T,_rec29)
(<_104> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_95> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'maybe_expand_segs'/1 = fun (_0) -> case _0 of <T = {'set',_24,_25,_26,_27,_28,_29,_30,_31}> when (try let <_6> = call 'erlang':'element' (3,T) in let <_5> = call 'erlang':'element' (4,T) in call 'erlang':'=:=' (_6,_5) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case T of (<({'set',_32,_33,_rec36,_34,_35,_36,_37,_38}-|['compiler_generated'] )> when 'true' -> let <_rec32> = call 'erlang':'*' (2,_rec36) in (case T of (<({'set',_40,_41,_42,_rec37,_43,_44,_45,_46}-|['compiler_generated'] )> when 'true' -> let <_rec33> = call 'erlang':'*' (2,_rec37) in (case T of (<({'set',_48,_49,_50,_51,_52,_53,_54,_rec38}-|['compiler_generated'] )> when 'true' -> (case T of (<({'set',_56,_57,_58,_59,_60,_61,_rec39,_62}-|['compiler_generated'] )> when 'true' -> let <_rec34> = apply 'expand_segs'/2 (_rec38,_rec39) in case T of <{'set',_64,_65,_66,_67,_68,_69,_70,_71}> when 'true' -> let <_20> = call 'erlang':'setelement' (9,T,_rec34) in let <_21> = call 'erlang':'setelement' (5,_20,_rec33) in call 'erlang':'setelement' (4,_21,_rec32)
(<_72> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_63> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_55> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_47> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_39> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<T> when 'true' -> T end
'maybe_contract'/2 = fun (_0,_1) -> case <_0,_1> of <T = {'set',_44,_45,_46,_47,_48,_49,_50,_51},Dc> when (try let <_7> = call 'erlang':'element' (2,T) in let <_8> = call 'erlang':'-' (_7,Dc) in let <_6> = call 'erlang':'element' (7,T) in let <_9> = call 'erlang':'<' (_8,_6) in let <_11> = call 'erlang':'element' (3,T) in let <_12> = call 'erlang':'>' (_11,16) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_9,_12)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case T of (<({'set',_52,_rec40,_53,_54,_55,_56,_57,_58}-|['compiler_generated'] )> when 'true' -> (case T of (<({'set',_60,_61,_62,_rec41,_63,_64,_65,_66}-|['compiler_generated'] )> when 'true' -> let <Slot1> = call 'erlang':'-' (_rec40,_rec41) in (case T of (<({'set',_68,_69,_70,_71,_72,_73,_74,_rec42}-|['compiler_generated'] )> when 'true' -> let <B1> = apply 'get_bucket_s'/2 (_rec42,Slot1) in let <B2> = apply 'get_bucket_s'/2 (_rec42,_rec40) in let <_25> = call 'erlang':'++' (B1,B2) in let <Segs1> = apply 'put_bucket_s'/3 (_rec42,Slot1,_25) in let <Segs2> = apply 'put_bucket_s'/3 (Segs1,_rec40,[]) in let <N1> = call 'erlang':'-' (_rec40,1) in (case T of (<({'set',_rec55,_76,_77,_78,_79,_80,_81,_82}-|['compiler_generated'] )> when 'true' -> let <_rec43> = call 'erlang':'-' (_rec55,Dc) in let <_rec44> = call 'erlang':'*' (N1,5) in let <_rec45> = call 'erlang':'*' (N1,3) in case T of <{'set',_rec47,_rec48,_rec49,_rec50,_rec51,_rec52,_rec53,_rec54}> when 'true' -> let <_36> = {'set',_rec43,N1,_rec49,_rec50,_rec44,_rec45,_rec53,Segs2} in apply 'maybe_contract_segs'/1 (_36)
(<_84> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_83> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_75> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_67> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_59> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<T,Dc> when 'true' -> (case T of (<({'set',_rec58,_85,_86,_87,_88,_89,_90,_91}-|['compiler_generated'] )> when 'true' -> let <_rec56> = call 'erlang':'-' (_rec58,Dc) in case T of <{'set',_93,_94,_95,_96,_97,_98,_99,_100}> when 'true' -> call 'erlang':'setelement' (2,T,_rec56)
(<_101> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_92> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'maybe_contract_segs'/1 = fun (_0) -> case _0 of <T = {'set',_22,_23,_24,_25,_26,_27,_28,_29}> when (try let <_6> = call 'erlang':'element' (3,T) in let <_5> = call 'erlang':'element' (5,T) in call 'erlang':'=:=' (_6,_5) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case T of (<({'set',_30,_31,_rec63,_32,_33,_34,_35,_36}-|['compiler_generated'] )> when 'true' -> let <_rec59> = call 'erlang':'div' (_rec63,2) in (case T of (<({'set',_38,_39,_40,_rec64,_41,_42,_43,_44}-|['compiler_generated'] )> when 'true' -> let <_rec60> = call 'erlang':'div' (_rec64,2) in (case T of (<({'set',_46,_47,_48,_49,_50,_51,_52,_rec65}-|['compiler_generated'] )> when 'true' -> let <_rec61> = apply 'contract_segs'/1 (_rec65) in case T of <{'set',_54,_55,_56,_57,_58,_59,_60,_61}> when 'true' -> let <_18> = call 'erlang':'setelement' (9,T,_rec61) in let <_19> = call 'erlang':'setelement' (5,_18,_rec60) in call 'erlang':'setelement' (4,_19,_rec59)
(<_62> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_53> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_45> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_37> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<T> when 'true' -> T end
'rehash'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[E|T],Slot1,Slot2,MaxN> when 'true' -> case apply 'rehash'/4 (T,Slot1,Slot2,MaxN) of <{L1,L2}> when 'true' -> case call 'erlang':'phash' (E,MaxN) of <_10> when call 'erlang':'=:=' (_10,Slot1) -> {[E|L1],L2}
<_11> when call 'erlang':'=:=' (_11,Slot2) -> {L1,[E|L2]}
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<[],_12,_13,_14> when 'true' -> {[],[]}
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'rehash',4}}] )-|['compiler_generated'] ) end
'mk_seg'/1 = fun (_0) -> case _0 of <16> when 'true' -> {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]}
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'mk_seg',1}}] )-|['compiler_generated'] ) end
'expand_segs'/2 = fun (_0,_1) -> case <_0,_1> of <{B1},Empty> when 'true' -> {B1,Empty}
<{B1,B2},Empty> when 'true' -> {B1,B2,Empty,Empty}
<{B1,B2,B3,B4},Empty> when 'true' -> {B1,B2,B3,B4,Empty,Empty,Empty,Empty}
<{B1,B2,B3,B4,B5,B6,B7,B8},Empty> when 'true' -> {B1,B2,B3,B4,B5,B6,B7,B8,Empty,Empty,Empty,Empty,Empty,Empty,Empty,Empty}
<{B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15,B16},Empty> when 'true' -> {B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15,B16,Empty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,Empty,Empty}
<Segs,Empty> when 'true' -> let <_4> = call 'erlang':'tuple_to_list' (Segs) in let <_2> = call 'erlang':'tuple_size' (Segs) in let <_3> = call 'lists':'duplicate' (_2,Empty) in let <_5> = call 'erlang':'++' (_4,_3) in call 'erlang':'list_to_tuple' (_5) end
'contract_segs'/1 = fun (_0) -> case _0 of <{B1,_6}> when 'true' -> {B1}
<{B1,B2,_7,_8}> when 'true' -> {B1,B2}
<{B1,B2,B3,B4,_9,_10,_11,_12}> when 'true' -> {B1,B2,B3,B4}
<{B1,B2,B3,B4,B5,B6,B7,B8,_13,_14,_15,_16,_17,_18,_19,_20}> when 'true' -> {B1,B2,B3,B4,B5,B6,B7,B8}
<{B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15,B16,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36}> when 'true' -> {B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15,B16}
<Segs> when 'true' -> let <_1> = call 'erlang':'tuple_size' (Segs) in let <Ss> = call 'erlang':'div' (_1,2) in let <_3> = call 'erlang':'tuple_to_list' (Segs) in let <_4> = call 'lists':'sublist' (_3,1,Ss) in call 'erlang':'list_to_tuple' (_4) end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('sets')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('sets',_0) end